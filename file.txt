#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

// Structure for tree node
struct Node {
    char data;
    struct Node* left;
    struct Node* right;
};

// Function to create a new node
struct Node* createNode(char data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Stack implementation for tree nodes
struct Node* stack[100];
int top = -1;

void push(struct Node* node) {
    stack[++top] = node;
}

struct Node* pop() {
    return stack[top--];
}

// Preorder Traversal (Prefix)
void preorder(struct Node* root) {
    if (root != NULL) {
        printf("%c ", root->data);
        preorder(root->left);
        preorder(root->right);
    }
}

// Postorder Traversal (Postfix)
void postorder(struct Node* root) {
    if (root != NULL) {
        postorder(root->left);
        postorder(root->right);
        printf("%c ", root->data);
    }
}

// Build Expression Tree from Postfix Expression
struct Node* buildTree(char postfix[]) {
    for (int i = 0; i < strlen(postfix); i++) {
        char ch = postfix[i];

        if (isalnum(ch)) { // Operand
            struct Node* operandNode = createNode(ch);
            push(operandNode);
        } else { // Operator
            struct Node* operatorNode = createNode(ch);

            struct Node* rightChild = pop();
            struct Node* leftChild = pop();

            operatorNode->right = rightChild;
            operatorNode->left = leftChild;

            push(operatorNode);
        }
    }
    return pop(); // Root of the tree
}

#include <stdio.h>
#include <string.h>

void findAndReplace(char str[], char find[], char replace[]) {
    char result[1000];   // final string
    int i = 0, j = 0, k;
    int findLen = strlen(find);
    int replaceLen = strlen(replace);

    while (str[i] != '\0') {
        // Check if substring matches
        if (strstr(&str[i], find) == &str[i]) {
            // Copy replacement into result
            for (k = 0; k < replaceLen; k++) {
                result[j++] = replace[k];
            }
            i += findLen; // skip past the word we replaced
        } else {
            result[j++] = str[i++];
        }
    }
    result[j] = '\0';

    // Copy result back into original string
    strcpy(str, result);
}

int main() {
    char text[1000], find[100], replace[100];

    printf("Enter text: ");
    fgets(text, sizeof(text), stdin);

    // remove newline if present
    text[strcspn(text, "\n")] = '\0';

    printf("Enter word to find: ");
    scanf("%s", find);

    printf("Enter replacement word: ");
    scanf("%s", replace);

    findAndReplace(text, find, replace);

    printf("\nUpdated Text: %s\n", text);

    return 0;
}

int main() {
    char postfix[100];

    printf("Enter postfix expression: ");
    scanf("%s", postfix);

    struct Node* root = buildTree(postfix);

    printf("Prefix expression: ");
    preorder(root);
    printf("\n");

    printf("Postfix expression: ");
    postorder(root);
    printf("\n");

    return 0;
}
